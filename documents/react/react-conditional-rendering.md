# React 조건부 렌더링

## context
> 조건부 렌더링 [공식 문서](https://ko.react.dev/learn/conditional-rendering)
- 컴포넌트 안에서 원하는 컴포넌트의 일부만, 즉 컴포넌트를 구성하는 특정 JSX 조각을 의도에 맞게 보여주거나 가릴 수 있다. 이때 렌더링 기준이 될 '조건'이 필요한데, React 공식 문서의 <조건부 렌더링> 파트를 보면서 (1) 조건이라는 것을 명시하는 방법, (2) 그 조건 하에서 무언가 보여주거나 보여주지 않는 방법을 익혀보려고 한다.


## opinion


## research

### 1. 조건부로 JSX를 렌더링 하기
> 컴포넌트는 조건에 따라 다른 항목을 표시해야 하는 경우가 많습니다. React는 if 문, && 및 ? : 연산자와 같은 자바스크립트 문법을 사용하여 조건부로 JSX를 렌더링할 수 있습니다.
- 그치, 정확한 표현은 '조건부로 JSX를 반환, 렌더링 한다'는 것이 맞다. '조건부로 컴포넌트를 렌더링 한다'는 표현도 정확하지 않을 수 있다.
- 컴포넌트 내 최상단에서 return은 'JSX 트리를 반환하는' 역할을 한다. 컴포넌트의 역할 === JSX 트리 반환.

> 중첩된 조건부 마크업이 너무 많아 컴포넌트가 지저분해질 경우 자식 컴포넌트를 추출하여 정리하세요. React에서 마크업은 코드의 일부이므로 변수 및 함수와 같은 도구를 사용하여 복잡한 식을 정리할 수 있습니다.
- 변수와 함수를 잘 활용하는 것이 중요한 건 알겠는데, 주의할 부분이 있을 것이다. 구현 중 특정 변수를 활용하려고 할 떄, 종종 아직 선언되지 않은 undefined인 타이밍에 걸려 예기치 않은 오류가 생긴적이 있다. 렌더링, 데이터 요청 등의 타이밍을 정확히 인지하고 있는 상태에서 변수, 함수 등의 도구를 더 잘 활용해봐야겠다.
  - 액션 아이템: 컴포넌트는 언제 왜 렌더링 되는가? (타이밍, 트리거 이해하기) #다시보기

### 2. When ... return: 조건을 명시해주는 방법

#### 2-1. if...else
- JavaScript로 익숙한 if...else 문을 써서 다른 컴포넌트가 분기에 따라 JSX트리를 반환하도록 할 수 있다.
```js
if (isPacked) {
  return <li className="item">{name} ✅</li>;
}
return <li className="item">{name}</li>;

```
- 하지만 위 코드 처럼 중복 코드가 발생할 수 있고(나쁘다는 건 아님), 코드 유지보수에도 어려움을 줄 수 있다. 덜 반복적(DRY, Don't Repeat Yourself)이게 할 수 있는 다른 방법이 있다.

#### 2-2. 삼항 조건 연산자 (? :)
> ”isPacked가 참이면 (?) name + ' ✔'을 렌더링하고, 그렇지 않으면 (:) name을 렌더링한다.” 라고 읽을 수 있습니다.
- 아래 코드를 위 공식문서 처럼 읽을 줄 알아야 함.
  - 왜 가능한지 추가로 삼항조건 연산자의 특징에 의거해서 보자면: "조건(삼항)연산자": false 이외의 falsy한 표현식에는 null, NaN, 0, 비어있는 문자열 (""), 그리고 undefined가 있습니다. condition이 이 중 하나일 경우 조건 연산자의 결괏값은 exprIfFalse 표현식을 실행한 결괏값입니다. [공식문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Conditional_operator)
```js
return (
  <li className="item">
    {isPacked ? name + ' ✅' : name}
  </li>
);

```
#### (+) if...else, 삼항연산자 방식은 결국 동일한가? 완전히 동일하게 서로를 대체할까? (결론 `Yes!`)
> <li>의 두 가지 다른 “인스턴스”를 만들 수 있기 때문에 객체 지향 프로그래밍에서는 위의 두 예가 미묘하게 다르다고 생각할 수 있습니다. 그러나 JSX 엘리먼트는 내부 상태를 보유하지 않으며 실제 DOM 노드가 아니기 때문에 “인스턴스”가 아닙니다. 이것은 청사진처럼 간단한 설명입니다. 따라서 위의 두 가지 예시 코드는 실제로 완전히 동일합니다. [공식문서](https://ko.react.dev/learn/conditional-rendering#are-these-two-examples-fully-equivalent)
##### 공식문서 문구에서 '두가지 다른 인스턴스'는 무엇을 의미할까?
- if…else에서 2개의 태그는 2개의 개별 DOM 요소를 의미하므로 '두가지 다른 인스턴스'를 말하는 걸까?
##### 'JSX 엘리먼트는 내부 상태를 보유하지 않으며'는 무엇을 의미할까?
- 위 두가지 다른 인스턴스로 볼 수 있는 시각을 착각이라는 것을 설명해주는 근거인 것 같은데, 정확한 뜻을 모르겠다.
- (참고) 영문 버전 발췌: "JSX 엘리먼트는 인스턴스가 아니다."
  - *But JSX elements aren’t “instances” because they don’t hold any internal state and aren’t real DOM nodes.*
##### 찾아본 것
- JSX 엘리먼트는 (실제 DOM 노드와 다르게) 메모리 상에서 일시적 존재하는 청사진에 불과하다는 의미. => 태어나지 않은 상황이며, 메모리상에서만 존재함.
- 리액트는 JSX 엘리먼트들을 '실제로 DOM에 반영하기 전까지는' 상태나 인스턴스를 가지지 않는다. => 태어나면, 즉 실제 DOM에 반영(커밋)되면 그제서야 상태/인스턴스를 갖는다고 볼 수 있다.

#### 2-3. 논리 AND (’&&’) 연산자: 보여주거나 아예 안보여주거나.
> 또 다른 일반적인 손쉬운 방법은 JavaScript 논리 AND (’&&’) 연산자입니다. React 컴포넌트에서는 조건이 참일 때 일부 JSX를 렌더링하거나 그렇지 않으면 아무것도 렌더링하지 않을 때 를 나타내는 경우가 많습니다.

> JavaScript && 표현식은 왼쪽(조건)이 true이면 오른쪽(체크 표시)의 값을 반환합니다. 그러나 조건이 false이면 전체 표현 식이 false가 됩니다. React는 false를 null 또는 undefined처럼 JSX 트리의 “구멍”으로 간주하고 그 자리에 아무것도 렌더링하지 않습니다
- 역시 공식적으로도 쉬운 방법으로 언급하고 있구나. 보통 언제 쓸지 정확히 말로 뱉기. “특정 조건이 참일때, 일부 JSX를 렌더링 하거나 아니면 아무것도 렌더링 안하려고 할 때 자주 사용합니다“라고.

#### (기타) &&의 왼쪽에 숫자를 두지 마세요. (실험해보기)
> &&의 왼쪽에 숫자를 두지 마세요. 조건을 테스트하기 위해 JavaScript는 자동으로 왼쪽을 부울로 변환합니다. 그러나 왼쪽이 0이면 전체 식이 (0)을 얻게 되고, React는 아무것도 아닌 0을 렌더링할 것입니다.
- 왜 자동으로 왼쪽을 Boolean으로 변환하지? #다시보기

#### 2-4. 변수에 조건부로 JSX를 할당하기: 코드가 길어질 수 있으나, 익숙하고 명시적이기 때문에 활용이 쉬울 수 있음.
```js
if (isPacked) {
  itemContent = name + " ✅";
}

```
> 위와 같은 방법이 일반 코드를 작성하는 데 방해가 되면 if 문과 변수를 사용하세요. let으로 정의된 변수는 재할당할 수 있으므로 표시할 기본 내용인 이름을 먼저 대입하세요.
- '이런 방식도 있구나' 가늠은 되는데, 정확한 의미를 코드로 이해해보기. 결국 조건부 렌더링할 때 어떤 방식을 취할지는 상황마다 다르겠다. 정답은 없고 내 기준 필요. 다 할 줄 알아야 함. 단순한 코드로 읽기 쉽게, 예측가능하게.
> 이 스타일은 가장 장황하면서도 가장 유연합니다. 코드가 잘 작동 중입니다.
- 코드가 길어질 수 있으면서도, 자유롭게 다룰 수 있어 활용도가 높다는 의견이겠다.


### 3. No return: 아무 것도 반환하지 않(화면에 보여주지 않음)
> JavaScript && 표현식은 왼쪽(조건)이 true이면 오른쪽(체크 표시)의 값을 반환합니다. 그러나 조건이 false이면 전체 표현 식이 false가 됩니다. React는 false를 null 또는 undefined처럼 JSX 트리의 “구멍”으로 간주하고 그 자리에 아무것도 렌더링하지 않습니다.
- (중요) 위 문장을 200% 이해하기. 만약 누군가 물어본다면? “리액트에서 && 연산자에 대해 아는대로 이야기 해보세요.“ 나는 어디까지 이야기할 수 있을까? + null, undefined 말고 false도 렌더링 하지 않음. 즉 ‘구멍’으로 간주함.


