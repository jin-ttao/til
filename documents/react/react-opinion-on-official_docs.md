# React 공식 문서 <학습하기> 읽고 opinion 기록

## context
- 리액트 공식 문서에서 [`<React 학습>` 파트](https://ko.react.dev/learn/describing-the-ui)를 읽고 의견을 기록한다.
- 진행 현황 (2024.10.23 기준)
  - UI 표현하기 `90%` (9/10)
  - 상호작용성 더하기 `0%` (0/8)
  - State 관리하기 `0%` (0/8)
  - 탈출구 `11%` (1/9)

## UI 표현하기
> 서로 다른 데이터를 사용하여 동일한 컴포넌트의 여러 인스턴스를 표시해야 하는 경우가 종종 있습니다.

- 💭 동일 컴포넌트에 서로 다른 데이터로 여러 인스턴스 표시하고 싶다. / map, filter 외에 배열 메서드를 더 쓸 수 있나?

> people의 요소를 새로운 JSX 노드 배열인 listItems에 매핑합니다.
- 💭 배열의 요소를 통해 JSX 노드를 담은 배열을 만들기

> 테스트에 통과된 항목(true가 반환된 항목)만 있는 새로운 배열을 반환합니다.
- 💭 map, filter 모두 새로운 배열을 반환하기에 가능한 것.

> `=> {` 를 표현하는 화살표 함수를 “block body”를 가지고 있다고 말합니다. 이 함수를 사용하면 한 줄 이상의 코드를 작성할 수 있지만 return 문을 반드시 작성해야 합니다. 그렇지 않으면 아무것도 반환되지 않습니다!
- 💭 리마인드: 화살표 함수는 암묵적으로 return!

> 각 배열 항목에 다른 항목 중에서 고유하게 식별할 수 있는 문자열 또는 숫자를 key로 지정해야 합니다.
- 💭 key로 문자열, 숫자만 가능하구나.

> Key는 각 컴포넌트가 어떤 배열 항목에 해당하는지 React에 알려주어 나중에 일치시킬 수 있도록 합니다. 이는 배열 항목이 정렬 등으로 인해 이동하거나 삽입되거나 삭제될 수 있는 경우 중요해집니다. key를 잘 선택하면 React가 정확히 무슨 일이 일어났는지 추론하고 DOM 트리에 올바르게 업데이트 하는데 도움이 됩니다.
- 💭 구체적인 key 활용 타이밍 궁금 #다시보기

> 각 항목이 하나가 아닌 여러 개의 DOM 노드를 렌더링해야 하는 경우에는 어떻게 해야 할까요?
- 💭 정확히 어떤 상황을 의미하는 것일까? #다시보기

> 로컬에서 생성된 데이터: 데이터가 로컬에서 생성되고 유지되는 경우(예: 메모 작성 앱의 노트), 항목을 만들 때 증분 일련번호나 crypto.randomUUID() 또는 uuid 같은 패키지를 사용하세요.
- 💭 3가지 케이스 각각 뭔지 이해가 필요할 것 같다?? #다시보기

> 폴더의 파일 이름과 배열의 JSX key는 비슷한 용도로 사용됩니다. 이를 통해 형제 항목 간에 항목을 고유하게 식별할 수 있습니다. 잘 선택된 key는 배열 내 위치보다 더 많은 정보를 제공합니다. 재정렬로 인해 위치가 변경되더라도 key는 React가 생명주기 내내 해당 항목을 식별할 수 있게 해줍니다.
- 💭 key는 배열의 JSX에 부여되는 것

> 즉석에서 key를 생성하지 마세요. 이렇게 하면 렌더링 간에 key가 일치하지 않아 모든 컴포넌트와 DOM이 매번 다시 생성될 수 있습니다. 속도가 느려질 뿐만 아니라 리스트 항목 내부의 모든 사용자의 입력도 손실됩니다
- 💭 key로 뭐가 달라지는지 보고 그거만 렌더링 한다는 말이구나?

> JavaScript의 map()을 사용하여 유사한 컴포넌트 집합을 생성하는 방법 <br> JavaScript의 filter()를 사용하여 필터링된 항목의 배열을 생성하는 방법
- 💭 filter는 map으로 컴포넌트 집합을 만들기 위해 필터링을 거들 뿐.

### 컴포넌트를 순수하게 유지하기 (컴포넌트를 순수하게 유지하여 혼란스러운 버그를 피하는 방법)

> 순수 함수는 오직 연산만을 수행합니다.
- 💭 컴퍼넌트는 순수해야 한다 == input, output 계산이 항상 동일해야.
- 💭 데이터 요청 같은 건 순수한 연산 과정이라 할 수 없나?
- 💭 데이터의 변화를 일으키는 것인가? 언제만 변화 일으킬지 정의하는 것이 useEffect?
- 💭 이 '순수성' 관점에서 컴포넌트는 최대한 작은게 좋나? 마냥 작은게 늘 정답은 아니고, 늘 작게 유지할 수는 없겠지만 크고 작음 보다 '순수성'이 더 중요한 기준일 것이다.

> 순수 함수는 다음과 같은 특징을 지니고 있는 함수입니다. <br> 자신의 일에 집중합니다. 함수가 호출되기 전에 존재했던 어떤 객체나 변수는 변경하지 않습니다. <br> 같은 입력, 같은 출력 같은 입력이 주어졌다면 순수함수는 같은 결과를 반환해야 합니다.
- 💭 함수 호출 전 존재했던 객체/변수를 변경할 수 있지 않나? 변경했을 때 안좋을 것 같긴한데 정확히 무엇이 문제일지.

> React는 작성되는 모든 컴포넌트가 순수 함수일 거라 가정합니다. 이러한 가정은 작성되는 React 컴포넌트에 같은 입력이 주어진다면 반드시 같은 JSX를 반환한다는 것을 의미합니다.
- 💭 항상 같은 jsx 반환할 수 있나? 데이터가 달라져서 콘텐츠가 달라지는데, 이건 차치하고 늘 같은 JSX 코드를 반환한다는 것인가?

> Recipe에 drinkers={2}를 넘기면 항상 2 cups of water를 포함한 JSX 반환합니다. drinkers={4}를 넘기면 항상 4 cups of water를 포함한 JSX를 반환합니다.
- 💭 아 같은 input에 늘 같은 output을 뱉는다는거구나. 음.. 그래도 문서 목록을 보여주는 캄포넌트라고 하면, 내가 어제 문서 목록을 볼 때, 그리고 문서를 몇개 더 생성한 오늘 문서 목록에 들어갈 때 ‘문서 목록’ 컴포넌트가 렌더링 하는 것은 다른거 아닐까?

> 컴포넌트를 마치 레시피처럼 생각할 수 있습니다. 만약 레시피를 그대로 따르고 요리하는 동안 새로운 재료를 도입하지 않는 이상 매번 새로운 요리를 만들 수 있습니다다. 그 “요리”는 React가 렌더하는데 컴포넌트가 제공하는 JSX입니다.
- 💭 리액트 공식 비유! 많은 의미를 함축하고 있다.

> React의 렌더링 과정은 항상 순수해야 합니다. 컴포넌트는 렌더링하기 전에 존재했던 객체나 변수들을 변경하지 말고 컴포넌트를 순수하지 않도록하는 JSX만 반환해야합니다.
- 💭 순수하지 않도록 하는 JSX만 반환해야 한다?? #다시보기

> 사이드 이펙트: 의도하지(않은) 결과
- 💭 이 부분이 필요했다… 역시 기본은 공식문서에 다 있다

> 이 컴포넌트는 컴포넌트 바깥에 선언된 guest라는 변수를 읽고 수정하고 있습니다. 이건 컴포넌트가 여러번 불리면 다른 JSX를 생성한다는 것을 의미합니다! 그리고 더욱이 다른 컴포넌트 가 guest를 읽었다면 언제 렌더링 되었는지에 따라 그 컴포넌트 또한 다른 JSX를 생성할 겁니다! 이건 예측할 수 없습니다.
- 💭 이래서 이전 존재했던 변수 바꾸면 안된다고 했구나. 다른 JSX를 반환하게 하기 때문에. 해결은 프로퍼티로 넘기거나, 컴포넌트가 이전 데이터를 토대로 계산하는 코드를 줄이고 그리는 거에 집중하게 하는 것도 방법일 것 같은데 현실적인 방법은 아닐 것 같다.

> 렌더링하는 동안 그냥 만든 변수와 객체를 변경하는 것은 전혀 문제가 없습니다. 이번 예시에서는, [] 배열을 만들고, cups 변수에 할당하고, 컵 한 묶음을 push 할 것입니다.
- 💭 오 이렇게도 렌더링 가능하구나!

## 탈출구 Escape Hatches
💭
> 탈출구 <br> 일부 컴포넌트는 React 외부의 시스템을 제어하고 동기화해야 할 수 있습니다. 예를 들어 브라우저 API를 사용해 input에 초점을 맞추거나, React 없이 구현된 비디오 플레이어를 재생 및 일시 정지하거나, 원격 서버에 연결해서 메시지를 수신해야 할 수 있습니다. 이 장에서는 React의 “외부”로 나가서 외부 시스템에 연결할 수 있는 탈출구를 배웁니다. 대부분의 애플리케이션 로직과 데이터 흐름은 이러한 기능에 의존해서는 안 됩니다.
- 💭 왜 챕터 이름이 탈출구일까?: React에서 '외부 시스템과 연결'될 때의 알아야 할 점을 정리해둔 챕터인 듯 하다. 브라우저 API, React 없이 구현된 무언가와 섞여서 동작할 때, 서버와 통신할 때 등 React 밖의 외부 시스템에 연결하는 방법을 배운다는 의미일 것이다.
- 💭 "대부분의 애플리케이션 로직과 데이터 흐름은 이러한 기능에 의존해서는 안 됩니다." 라고 하는데, 외부 시스템에 의존하는 로직과 데이터 구조는 좋지 않다는 의미인가? 의존의 정도는 어떻게 평가할 수 있을까?

### useRef
> 다시 렌더링 하지 않고 정보를 '기억'하는 방법 <br> 컴포넌트가 일부 정보를 “기억”하고 싶지만, 해당 정보가 렌더링을 유발하지 않도록 하려면 ref를 사용하세요. <br> `const ref = useRef(0);` <br> ref는 React가 추적하지 않는 컴포넌트의 비밀 주머니와 같습니다. 예를 들어 ref를 사용하여 컴포넌트의 렌더링 출력에 영향을 주지 않는 timeout ID, DOM 엘리먼트 및 기타 객체를 저장할 수 있습니다.

- 💭 '값은 기억하고 싶지만 렌더링을 일으키고 싶지 않을 때' 사용하는 것 같다. 아직 사용해본 적이 없지만, '화면에 그릴 것과 연관이 없는 데이터를 관리할 때' 사용하게 될까? 화면에 그릴 것과 무관한 데이터가 어떤 것이 있을까? `ref`로 쓰면 좋은 데이터를 예시로 확인해보자.

- 💭 '리액트가 0.016초 렌더링이 되고 있다'는 표현이 있는데, 렌더링이라는 표현이 맞을까? Ref와 연관이 있는 개념인데, 리액트는 사실 계속 렌더링을 하고 있고 다른 부분이 발생했을 때만 코드적으로 렌더링(컴포넌트 함수를 호출)한다고 한다. 리액트 내부에서 어떻게 돌아가는지 한 번 더 체크하기.

- 💭 ref의 구성요소는 결국 2가지일 것. (1) 무엇을 ref 할 것인가 (2) 초기값은 무엇인가 (그나저나 초기값 null은 무엇을 의미하나?)

> React가 관리하는 DOM 요소에 접근해야 할 때가 있습니다. React는 이런 작업을 수행하는 내장 방법을 제공하지 않기 때문에 DOM 노드에 접근하기 위한 ref가 필요할 것입니다.

- 💭 ref 통한 DOM 조작 사례 더 살펴보기. 리액트로 첫 프로젝트를 했을 때, 이전 자바스크립트로 DOM 요소에 접근하는 것 처럼 `querySelector`를 사용했었다. 이 때 피드백으로 리액트에서는 직접 DOM을 조작하지 않도록 해야 한다는 피드백을 들었다. 리액트가 DOM을 관리하고, 우리는 DOM을 직접 건드리면 안된다는 정도로 이해하고 넘어갔던 기억이 있다. 그런데 직접 DOM 조작을 하면 어떤 문제가 발생하는가? 리액트의 어떤 점을 방해하는 건가?

> 컴포넌트는 외부 시스템과 동기화해야 합니다. 예를 들어 React state에 따라 React가 아닌 컴포넌트를 제어하거나, 채팅 서버에 대한 연결을 설정하거나, 컴포넌트가 화면에 나타났을 때 분석 로그를 보낼 수 있습니다. (...) 컴포넌트를 React 외부 시스템과 동기화할 때 이를 사용하세요.

- 💭 컴포넌트가 외부 시스템과 동기화 된다는 것은 이런 흐름일 것이다. (1) 컴포넌트 내부의 변화(주로 주범은 '상태'일 것) > (2) 바뀐 상태에 따라 외부 시스템도 변화가 필요함 > (3) 이어서 외부 시스템의 응답에 따라 보여줄 값도 다시 갱신해줘야 할 것 (리렌더링).

- 💭 'React가 아닌 컴포넌트를 제어'하는 경우가 어떤 경우일지 궁금했는데, 공식문서 예제에서 다루고 있었다. video라는 HTML 태그를 ref로 지정해서, 내부 상태(재생 여부)에 따라 리액트 컴포넌트가 아닌 HTML 태그의 play/pause를 Effect로 제어했다.

> 특정 이벤트를 처리하는 이벤트 핸들러와 달리 Effect는 렌더링 후 일부 코드를 실행합니다.

- 💭 Effect의 코드 실행 타이밍을 이벤트 핸들러와 비교하고 있다. 유사점도 있기 때문에 이렇게 차이를 강조하는 것으로 보이는데, 불필요한 Effect를 거론할 때 '특정 이벤트 후 코드를 실행하고 싶을 경우'를 말한다. 이벤트 핸들러로 문제가 해결되는데 불필요하게 useEffect를 사용하지 말자.
