# algorithm-review-202411

## 35. Search Insert Position
> 1차 풀이: 총 1시간 10분 소요
```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
const searchInsert = function(nums, target) {
    const indexOfTarget = nums.indexOf(target);

    if (indexOfTarget >= 0) {
        return indexOfTarget;
    }

    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > target) {
            return 0;
        } else {
             if (i === nums.length - 1) {
                return nums.length;
            }

            if (nums[i] < target && nums[i + 1] > target) {
                return i + 1;
            }
        }
    }
};
```
#### 시간 복잡도 O(log n)를 맞추는게 조건인데 어떻게 할 수 있을지 고민.
=> 다 풀고 찾아보니 O(log n)는 '문제 해결에 필요한 단계들이 연산 마다 특정 요인에 의해 줄어든다'는 의미라 이진탐색 처럼 조건을 좁혀나가야 한다고 한다.
=> 다음에는 이진탐색으로 풀어보기**
#### 문제의 핵심 정의, 어떤 자료구조를 활용할지 정하고 방향 고민해도 좋겠음.
#### 첫 시도: 이진 탐색으로 풀어보자. 냅다 중앙값을 정의하려 했는데, 생각해보니 이진탐색의 핵심은 중앙값이라기 보다 단지 중앙값을 '비교할 기준값'으로 활용하는 접근.
- 테스트 케이스에서 충족하지 못하는 케이스 발견해서 다른 접근법 고민. => 테스트 케이스의 중요성! 테스트 케이스가 곧 해결해야할 문제이고 요구사항임.
- 다른 사람 풀이를 보니 이진탐색도 가능한 방법이었음. 내가 지금 이진탐색을 잘 모르는 듯.
#### 두번째 시도: 배열 요소 처음 부터 순회하면서 반복
#### (모순적이게도) 반복은 종료를 위해 하는 것. 목표가 있기 때문에 무언가 반복하는 것이고, 목표가 무엇인지 정의하는 건 당연히 중요.
#### 반복문, 조건문으로 뭘 할지 바로 떠오르지 않았음. 문제에서 잠시 떨어져서 생각해봤다. '반복문은 뭐고 언제 쓰지', '조건은 왜 필요하지'.
- 이렇게 원론적으로 생각하니 명확해졌다. 말 그대로 '반복 하려고', '시작, 끝 등 조건을 규정하려고' 각각을 사용하는 것.
- 이걸 내가 해결하려는 상황, 의도에 대입해서 생각했다.
- 사고 프레임 찾아보고 안풀리면 여쭤보기: while 조건문에 들어가는 것, 블록 안에 넣을 것.
#### 오래 걸린 것: while 조건문 안에 뭘 넣어야 할까, 정렬 기준대로 알맞는 자리에 위치 시키는 방법
=> 즉 언제까지 반복할 것인지 정의. 뭘 반복할지는 비교적 쉬웠는데 반복 조건을 정하지 않은 상태에서 반복 작업을 제대로 정의할 수 있을까.
=> 정렬 알고리즘을 여러개 고민했었는데, bubble sort, Insertion sort, merge sort 등.
#### 알고리즘 흐름이 순서가 명확해야 하고, 정답 까지 최대한 좁혀나가는 사고로 접근해야 함.

