===========================

## 추가로 정리할 부분

SQL, NoSQL
Documents, Collection 용어들의 관계...
SQL은 Table, Column으로 구분.

#### endpoint

what is endpoint?
https://stackoverflow.com/questions/2122604/what-is-an-endpoint

# 10/25 금

## 프로젝트 A 회고

렌더링 횟수도 예측하기. 렌더링 타이밍은 예측하기 어렵더라도, 렌더링 횟수는 예측하기.
테크닉은 빨리 습득
기본기에 고민 더하기
children, Outlet 차이
보호하고 싶은 컴포넌트를 wrapper로 감싸고, children으로
로그인을 검사하냐,

### 최적화

### 라우팅 Routing

#### refactor: 로그인 및 권한 validation을 각 페이지 컴포넌트의 역할로 변경.

- 배경: 유저가 새로운 화면을 볼 때 마다, 매번 로그인 상태를 점검하고자 했다.
- 모든 컴포넌트에서 로그인 상태를 validate 해줘야 할지 고민했었다.
- 하지만 결국 상위 루트 컴포넌트에서 로그인 상태가 아니라면 라우팅이 선언되지 않도록 하는 것으로 처리해두었다. 루트에서 라우팅을 막아두면 하위 모든 컴포넌트에서 해당 경로들로 진입이 안될 것이라 생각했기 때문이다.
- 1차 구현 후 멘토님께 질문을 드렸다. '루트에서 로그인 검사하는 것 vs 각 컴포넌트에서 로그인 검사를 따로 해주는 것 중 어떤 게 좋은 관습인가요?' 구현 방식이 로그인 validate을 처리해줄지 확신이 부족했기 때문에 나온 질문이었다. 맨토님의 조언은 우선 '의도' 부터 정의해야 한다였다. 결국 정답이 없어서 '의도를 정의하고 그것을 정확하게 구현하는 것'이 중요하다는 것이다.
  최초 진입, 로그인이 갑자기 풀렸을 때 모두 설계 의도대로 작동할까?

리팩토링 과정에서 사용자 로그인 및 접근권한 validation, 로그인 후 redirect 방법에 대해 고민을 많이 했다.

- 사용자의 로그인, 접근권한 validation은 React Router 구조를 함께 고민했는데, 처음에 컴포넌트, 라우팅 구조를 촘촘히 설계해야 함을 배웠다. 즉 로그인 검사(검사 위치, 주기, 방법) 에측 가능하고, 의도가 담겨야 한다.
- (참고) stackoverflow https://stackoverflow.com/questions/48497510/simple-conditional-routing-in-reactjs

`<Routes></Routes>`의 자식 요소는 `<Route>`만 품을 수 있다. 로그인 validation 용도로 컴포넌트 `<ProtectedRoute>`를 직접 만들어서 Routes의 자식 요소로 두었는데 "`<ProtectedRoute>`는 `<Route>` 컴포넌트가 아니다."라는 에러가 발생했다. 명시적으로 이름이 `<ProtectedRoute>`인 컴포넌트를 자식 요소로 가질 수 없으므로, path에 매핑하는 `element`에 `<ProtectedRoute>`를 명시하는 것으로 해결할 수 있다.

수정한 버전에서는 App 컴포넌트 경로 설정에 집중했다. 그전에는... 관심사 분리라고 볼 수 있을까? 분기 처리도 루트 컴포넌트 App에서 일괄적으로 해줬는데, 상단에서 해주면 한눈에 보기 편하다는 장점이 있을 수 있지만, 그다지 장점은 아니었던 것 같다. 오히려 각각의 자식 컴포넌트에서 어떤 조건일 때 자식 본인이 렌더링 될지 명시해두는게 명확했던 것 같다.

### 라우팅

- 체크) 라우터 절대 경로, 상대 경로 개념 헷갈리면 안됨. 아래 2가지 차이점 설명하기.
  - navigate(`/${userId}/edit/${documentId}}`);
  - navigate(`${userId}/edit/${documentId}}`);

#### - 라우터 경로는 default로 상대 경로로 라우팅 하고, 절대 경로로 라우팅 하고 싶으면 지정해주면 됨.

- 체크) 이거 2개 차이 무냐?`<Link to={"list/edit"}>` `<Link to={"/list/edit"}>`

- => 리액트 라우터 디버깅에도 리액트 데브툴이 도움 되었다. 지금 App이 감싸고 있는게 뭔지, 현재 위계가 내 의도와 같은지 알 수 있게 해줘서 중첩 라우팅 코드 구조를 철회할 수 있었다.

### 시간 오래 걸린 것

#### 2일차: 전역 상태 정의, 업데이트 고민

- 전역 상태로 정말 필요한지, 그외 방법은 없는지 점검하는 습관 기르기
- 상태 변경을 코드적으로 어느 위치에서 해주는게 맞는지. 로그인 상태를 어느 컴포넌트에서 업데이트 해줘야 의도한 흐름으로 동작할지, 나아가 무엇이 권장될지 까지 생각하면서 적용 까지 시간이 걸렸다.

#### 3일차: 라우팅

- 오후는 라우팅에 가장 많은 시간 쓴 듯. 1시 30분 부터 3시 30분 까지.. .signin을 별도 컴포넌트로 뺐던 터라 이 구조에서는 새로운 구조가 필요했다. signin을 굳이 별도 라우팅할 컴포넌트가 아니라 헤더 컴포넌트 안에서 렌더링 했으면 편했을 것. App 컴포넌트 안에서 특정 경로에 렌더링 할 컴포넌트로 매핑하는 과정에서 로직이 꼬여버렸다. => 그냥 로그인 된 상태일 때에는 문서 보여주게만 하면 됨.

- 결국 상태를 잘 다루지 못해서 이렇게 애먹음... 전역 상태로 두면 편하긴 하겠다. 에디터에 문서 정보 전달하는거 하나로 4시간 쓰는게 말이 되나? 이펙트도 잘 못다뤄서 타이밍 엉키고, 비동기 함수 실행시킬 줄 몰라서 애먹고.... / / 의존성 배열 원시값 참조값... 이펙트 다루기..

### Warning 해결

![warning-router-bad-setState](/assets/warning-router-bad-setState.png)
![warning-navigate-in-useEffect](/assets/warning-navigate-in-useEffect.png)

### Effect

#### refactor: 리팩토링을 하면서 effect를 조금씩 줄여나갔다.

/\* 원래는 Effect로 썼는데, 조건부 렌더링으로 해결! 대신 return 꼭 써줘야 함.

- 왜 useEffect를 안쓰는게 좋을까? 명확성, 예측 가능성, 성능
  // 부수 효과로서의 네비게이션 vs 렌더링의 자연스러운 일부로서의 네비게이션
  // useEffect는 렌더링 후 실행 vs 조건부 렌더링은 즉시 실행
  // useEffect는 추가 렌더링 사이클 발생 가능 vs 조건부 렌더링은 단일 렌더링 사이클
  // 더 나은 에러 처리와 로딩 상태 관리
  // 테스트하기 더 쉬운 구조

JavaScript에서 in 연산자는 객체의 프로퍼티 이름(키)을 확인함. 배열이라면 프로퍼티 이름이 index이기 때문에 index로 확인 가능하긴 함.

비동기

- 비동기 함수의 반환값이 어떻게 되고, useEffet 안의

- 문제 단순화

- 로컬 상태로 최대한 해보기. 로컬 나고 글로벌 났지, 글.. 반대냐? 어떤 접근이 더 좋을까?

### Firebase

- 파베 ref() 가져오는 거 각각 코드 하나하나가 무슨 의미인지 이해하기.

useEffect
체크) 원시값으로 의존성 배열 두니 좀 나아졌다... 의존성 배열 원시값 참조값 > 가급적 원시값 쓰는게 좋나?

체크) onClick={() => handleClick(document.id)} 과 onClick={(document.id) => handleClick(document.id)} 차이는?

- 무한 렌더링 되는 이유:

```js
function 컴포넌트A() {
  if (경로가 B가 아닐때) {
    navigate(경로C) // 이때 경로C로 가게 되는데, 이때 경로B가 아닌게 항상 참이고, 경로C가 컴포넌트A를 항상 렌더링 하면 무한 렌더링이 발생할 수 있겠다. 이걸 막으려면 어떻게 하지?
  }
}
```

문제정의: FB에 문서 데이터 요청하는 로직을 어디에 두고, 결괴를 어떻게 전달할 것인가?

> > 그냥 각각 컴포넌트에서 필요하면 알아서 하면 안되나?

useEffect 타이밍 밀리는 이슈 왜 발생할까? 코드 복붙해두고 원인 파악하기
의존성 배열 계속 찝찝하다. 배열 안에 모든 변수를 넣지 않고 싶은데 린트 에러가 계속 뜸.

체크) useEffect 가 의존성 배열이 같은 effect가 있을 경우 동시에 실행될 수 있을 것 같은데 이유를 설명할 수 있어야.

- 리액트에서 side effect 정의: 컴포넌트가 호출되면서, 렌더링 외에 발생하는 모든 것.

체크) 에러, 로딩을 상태로 다뤄보는 연습

- 체크) 자바스크립트 객체와 JSON의 차이는?
- 템플릿 리터럴: 연산되는거라 한번에 감싸는게 나음.
  - 템플릿 리터럴 내에서 JavaScript 변수나 표현식을 ${ }로 감싸면 결과가 문자열에 포함됩니다.
  ```js
  const one = "Hello, ";
  const two = "how are you?";
  const joined = `${one}${two}`; // 따로 해서 문자열 합치지 말고 이렇게 통으로 감싸기.
  console.log(joined); // "Hello, how are you?"
  ```

단순
고민) wrapper container 차이

- 원론적 의미 구분 : container는 하나 이상, wrapper는 하나의 요소를 포함
- 그외 참고 [링크](https://velog.io/@na_0_i/Container%EC%99%80-Wrapper-%EB%91%90-%EC%9A%A9%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)
- 고민) component list entry 엔트리 컴포넌트명 정확히 의미가 뭘까
- 고민) 스타일 css `:root` ,`#root` 차이 https://blueprint-12.tistory.com/365
- 고민) 테일윈드 purge 옵션 이제 필요 없어짐 [링크](https://github.com/Learning-Is-Vital-In-Development/23-12-FrontendPerformanceOptimizationGuide/issues/34)
  - 테일윈드 참고한 좋은 글 - 워니 [링크](https://wonny.space/writing/dev/hello-tailwind-css)
- 고민) 시멘틱 태그 최대한 적용해보기
  - header nav 차이 / sec
  - 시멘틱 태그: `**<header>, <nav>, <article>, <section>, <footer>, <main>** `등이 존재함 [링크](https://seo.tbwakorea.com/blog/what-is-semantic-tag/)
- 고민) 페이지, 컴포넌트 레이어를 잘 활용하기. 아직 여러 컴포넌트를 중첩해서 쓰는 것이 익숙하지 않은 듯.
- 고민) 가장 최상단 루트인 main.jsx에서 응당히 해줘야 할 세팅은 뭐고, 각 역할이 뭔가?

```js
// react, react dom도 import 해줘야하는거 아닌가...
import { StrictMode } from "react"; // 이거 2개가 필요 없어짐.
import { createRoot } from "react-dom/client"; // 이거도 삭제함. 차이 비교하기/
import App from "./App/App";
import "../src/styles/index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

체크) 이건 왜 뜨는거지 main에서 "`*`"으로 바꿔주니까 해결됐다.
![alt text](image.png)

- 트러블 슈팅) `Firebase: No Firebase App '[DEFAULT]' has been created` 오류가 갑자기 잘 해결되었다. 무슨 차이이지......

- 체크) userId를 우선 Math.random()으로 구현해뒀는데 많이 사용되는 관습이 있는지 찾아보자.

- Firebase가 뭐만 하면 계속 '객체의 인스턴스를 생성'을 먼저하고 세팅해야하는 이유는? 참조값과 연관 있겠다.

  - 체크) 이거도 참조값 개념이다. 기본기가 있어야 함. 그래서 원본에도 영향을 주는 것... => 그래서 인스턴스가 필요한거임!!
  - `firebase.auth().setPersistence` 인증 상태 지속성 메소드 까보기
    ![alt text](image-1.png)

- Firebase 소셜 로그인 관련 cross origin 에러?
  ![alt text](image-2.png)

- 비동기면 습관적으로 catch를 쓰지 말고, 에러도 예측하자. 정확히 어떤 에러를 잡기 위해 catch를 썼는가?

- `??`는 언제 사용하나?

## 구체적인 액션 아이템

## 장황한 회고

- 잘 되고 있는 것 같긴 한데, 왜 이리 찝찝하지. 전체 기능을 아직 모두 MECE 하게 정의하는게 아니라 그런 것 같다. 정의한 문서 기준으로는 10%를 진보한 것 같은데 막상 5% 나아간 것 같은 느낌. 근데 당연할 수 밖에 없음. 그냥 만들자 ㄱㄱ.
- 공식 문서는 당연히 다 알려줄 수 없을 것이다. 말 그대로 공식이기 때문에, generic 내용만 다룰 수 있을 것이고. 사람들은 보통 개념을 처음 접하거나 문제에 부딪혔을 때 공식 문서를 찾는데, 당연히 일반적인 내용만 다루는 공식문서는 우리의 갈증을 해소시켜주기 어렵다. 우리는 이미 문제가 복잡하게 얽힌 맥락을 들고 왔는데, 이걸 공식 문서가 용케 알아 차려서 시원하게 처리해주기 어려운게 당연할 것이다. 그래서 공식 문서를 언제 어떻게 활용할지, 그리고 부족한 부분은 어떻게 보완할지 자신 만의 방법을 찾는게 중요한 것 같다. 대체로 권장되는 방법은 '왠만하면 공식 문서를 먼저 확인하라'는 말이 있는데, 80% 정도 동의한다. / 내 경험상 공식 문서는 . 3단계 정도에서 유용했음. .... 추가 서술하기.

뤼이드, 당근에서 비개발자로서 여러 데이터베이스를 까보고 sql로 고민했던게 도움이 된다. 좋은 데이터베이스, 실제로 좋았던 경험을 하니 나도 최대한 그렇게 짜보려고 한다.

## 기술적 회고

- 고민) 로그인 구현할 때 token, OAuth를 많이 들었는데 이번 기능 구현에서는 딱히 필요할 것 같지 않다. (결국 OAuth는 '데이터 접근의 권한을 위임 받는 것'을 의미함.)
  - 참고자료 https://hudi.blog/oauth-2.0/
- 대략 글로벌 상태 관리가 필요할 것 같으면, 왠만하면 다 글로벌 상태로 주고 나중에 로컬 상태로 최적화 시키는게 나을듯. 로컬 상태로 하니까 테스트가 끊긴다. 로그인 기능을 모든 사이클에서 테스트 하고 싶은데, 기능 동작은 하는데 실제 데이터에도 잘 박히는지 끝까지 추적하는게 어려움.
- 고민) ## Context API도 라이브러리인가? 리액트 내장되어 있더라도 라이브러리라고 할 수 있나? 훅이 아니라?
- 컴포스트랑 같이 손그림으로 컴포넌트 플로우차트로 케이스 나누기 (로그인 언제 검사하는지, 어떤 플로우로 보내야 하는지)
- 결국 데이터, UI가 전부. 기능이 복잡해보이면 이 단위로 쪼개서 또 쪼개보자.
- 나중에 체크) 서버에서 하는 일을 클라에서 점차 담당하기로 했다 [좋은 블로그 글](https://velog.io/@svk5496/React-Query-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C)
- 나중 체크) localhost란? 자꾸 등장하는데 잘 모름

- 중요 디버깅) 와.... set은 가장 가까운 set을 참조했었나...? 필요없는 변수 두면 이렇게 될 수 있구나... 미리미리 지우고 같은 변수명은 조심하자.
- - 고민) 훅 규칙이 생각보다 까다롭다고 처음 느겼다. 특히 쥬스탠드로 스토어 안팎에서 가져다 쓸 때, 컴포넌트 안에만 쓸 수 있다 는 규칙이.. 그냥 함수 안에서나 밖에서 쓸 수 없어서 리액트 컴포넌트 안에서만 쓸 수 있는게 걸렸다. 커스텀훅을 만들어야하나 생각했다.

---

# Keep

- 요구사항을 있는 그대로 두지 않고 최대한 소화하고자 했다.
  - 요구사항을 충족시키기 위해, 내가 만들 수 있는 최적의 방법과 세부기능은 무엇일지 재정의하고 문서화했다. 이전 프로젝트에서 요구사항을 받은 문장 그대로, 정돈하지 않은 상태로 급급하게 기능을 만들어갔다. 이때 구현 과정, 결과물을 내가 통제하고 있다는 느낌이 없고 끌려간다는 느낌을 받았다. 다른 동기들과 여러 아티클을 보면서, 요구사항을 받은 후 기능을 스스로 재정의하고 하위작업을 사전에 상세하게 나누는 것이 필요하다는 것을 알게 되었다.
  - 이 점을 이번 프로젝트에서 적용해보았는데 효과를 톡톡히 보았다. 유용한 정보는 자주 검색하고 들여다보기 마련인데, 이게 그랬다. 내가 한 번 정리한 문서를 매번 나 스스로 찾게 되었고, 이게 중요한 이정표가 되었다. 거시적으로 무엇이 중요한 기능인지, 의존성은 어떠한지, 일정에 따라 어느 기능에 힘을 줘야할지 등 '내가 프로젝트를 통제하고 있다'는 인상을 느꼈고, 실제 결과물로써도 기능 1개 외에 모두 구현할 수 있었다.

일정 관리

- 프로젝트를 해내는 나만의 프레임워크를 최적화 하기: 가령, 뼈대 잡고, 테스트를 하기 쉽게 계정 연동을 먼저 하고, 여러 시나리오 대응, 공동 작업... 2일 전 모든 기능 완성하고, 테스트 하면서 보완할 버퍼 마련하고,, 유효성 검사도 추가로 보완하고.. 등 규칙을 정해두고 최적화 하는게 좋을 것 같다.
- 프로젝트 일정에 쫓기지 않으려면, 1-2일차에 최대한 달려둬야 한다. 오늘 내일 80% 끝내려면? 어떻게 해야할지 계속 생각했음. 80% 정의. 큼지막한 덩어리 phase 구분.
- 해야할게 많은 사람이 더 많은 일을 빨리 해낸다는 말이 있다. 나 스스로 마감 일정을 제출 일정 보다 일찍 잡고, 요구사항 이상의 추가 good to try 기능(배포, 유효성 검사 보완, 에러 핸들링, 스타일링 등)을 더 만들어서 생산성을 스스로 높이려고 시도 했다. 결국 하방을 높였다.

- 코드 한줄이라도 더 쳐보려고하기. 진짜 독하게. 잠은 필요하면 필요한만큼 자려고 노력함.

- 4.5일간 누적 commit 72개.

  - 단순 개수가 중요한 건 아니지만, 개수가 없으면 증명할 수도 없다.
  - atom commit

- 로직이 복잡한 부분은 의사코드로 먼저 하나씩 정의한 것.

- 산책하면서 환기하는 것이 나에게 맞는 방법인 것을 발견함. 생각을 정리하고, 중요한 것이 무엇인지 다시 생각하면, 새로운 접근법이 보임.

- 계속 메모했다. 휘발 되지 않게, 기술적으로 어려운 부분, 잘 된 부분, 다시 살펴볼 부분, 기술을 선택한 이유.

# Problem

- 데이터 통신 중 '캐싱'이 유익한 상황을 오해해서, 잘못된 이유로 상태 관리 라이브러리를 결정할 뻔 했다.

  - 데이터 통신, 비동기,
    클라이언트 상태 보다, 서버 상태로 관리할 것이 더 많고, 데이터 요청이 잦을 것으로 예상해서 비동기 데이터를 상태로 관리할 때 강점이 있다고 하는 React Query에 리서치, 튜토리얼을 익히는 데에 3시간 이상 투자했다.
    다행히 멘토님께 질문을 드려서 내가 오해한 부분을 바로 잡았고, 너무 늦지 않은 상황에서 다른 라이브러리로 적용시킬 수 있었다. 사용할 라이브러리를 스스로 찾고 결정하는 것이 처음이라, 무엇을 염두에 둬야할지 감을 잡지 못했다.
    현재 구조상 서버 상태(유저, 문서 데이터)가 클라이언트 상태 보다 더 많이 필요하고, 서버의 상태 변경이 더 잦을 것이라고 판단했다. 성능, 코드 작성 효율화를 위해 라이브러리를 선택한다면 서버, 즉 파이어베이스와 비동기로 통신하는 것에 강점이 있는 라이브러리를 택하자고 판단했다. React Query가 이 분야에 '캐싱’, ‘데이터 패칭’ 강점이 있고, 클라이언트 상태 관리에도 사용 가능했고, Redux에서 전환하는 경우도 왕왕 발견되었다.
    (다른 라이브러리를 React Query 만큼 더 깊게 조사해보지는 못 했습니다)
  - 솔직히 React Query가 정확히 무엇을 어떻게 도와줄 수 있을지 아직 감이 안옵니다! 오히려 발목을 잡을 수 있다는 불확실성이 있는 상황이에요. 
  - 결국 현재 결정은 “집중적으로 해결할 문제는 ‘문서 공동 편집’인데, 이전에 가져온 문서 본문 `document content` 데이터가 있으면 속도는 느릴지언정 다른 라이브러리 보다 실시간 변경된 최신 버전을 상대적으로 매끄럽게 전환될 것이다”로 결정했다고 봐주시면 될 것 같습니다! 마감일정이 있어서 더 상세하게 뭐가 필요할지 정의하거나, PoC가 더 필요한 부분이 있을지 먼저 인지하고 가보려고 합니다!
    결론: 데이터가 많이 변하지 않을 때 캐싱을 많이 찾음. (반대로 생각했던 것 같음) >> 실시간 바뀌어서 캐싱이 무의미했음. 공동 편집이라고 하면 리액트 쿼리는 ㄴㄴ. 공동 편집은 변경 감지가 되면 >> 데이터를 불러오는 로직이 데이터를 가져올 수 있으면 보여줄 수 있음.

- 중첩 라우팅 써야할 때를 잘 모르고, 부모 자식 컴포넌트 관계라고 보고 먼저 적용했던 것이 잘못.

# Try

- 발표 준비도 나만의 방법을 더 디벨롭.

  - 계획 나쁘지 않았지만, 실전에 좀 약했던 것 같다. 거시: 코드 이전에 전체 구조 부터 설명. 왜 이런 구조를 짰는지 한 문장. 주요 파일들 최대5개, 각각 함수나 캄포넌트들은 무엇을 하나. 가령 firebase 파일에는 어떤 함수들을 들고 있는지/ 미시: 코드 하나하나의 이유

- 다른 분들 코드 보면 복잡하고 다양한 코드를 실제로 많이 적용했음. 나도 내 기준에서 보면 실력이 많이 늘었지만,

- 테스트 코드 작성: 시간 내 하지 못했음. 나중에 개인 프로젝트에서 해보자. 중간 어떻게 하면 되는지 유튜브로 접했음. 비용이 많이 드는 e2e 테스트 보다는 단위 테스트가 좋다고 하는데, 하나라도 적어보려다가 못했음.

- 공식 문서, 블로그에서 찾아볼 수 있는 것들을 더 명확히 이해한 상태로 적용하기. '이게 최선인가?'에 대해 확신이 없는 상태에서 적용하는 순간도 있었다. 이건 경험이 채워줄 수 있는 부분일 수도. 처음 부터 완벽히 확신을 갖고 적용하기는 쉽지 않음. 결정 순간의 이유가 명확하고 검증된 이유이기만 하면 됨.

## 알게 된 것

- 처음에 "전역 상태 라이브러리 꼭 필요할까?"싶었음. 파이어베이스가 필요한 컴포넌트에서 개별적으로 매번 서버 요청을 보내는게 아니라, 한번 요청한 곳에서 들고 있으면 됨.

- 서버에 저장한다고 클라이언트 상태로 안들고 있을 필요가 있나? 한번 가져와서 계속 들고 있을수도 있지 않나?
  - 처음에는 둘 중 하나만 써야 하는 것 처럼 받아들여졌다. 하지만 한번 가져와서 클라이언트 전역 상태로 업데이트 해두는 것이 합리적인 접근이 맞았던 것 같다.
  - 관련 참고해볼만 https://medium.com/@joeponzio/the-right-way-to-add-firebase-to-your-react-project-using-react-hooks-a32db20bf1a0
- 리액트에서 옵셔널 체이닝을 쓰기도 하는구나. 리액트 쿼리 공식 문서 보다가 발견!

- 고민) 어제 밤 부터 '로그인 상태 업데이트'를 어디서 해줘야 할지 감을 못잡고 있었다. 지금 보면 Zustand Action으로 두는게 당연했는데 헛발을 짚고 있었다. firebase?, App이나 Signin 컴포넌트에서? 정말 다른 방법이 없을까? 이걸 파보면서 Zustand Action에 두는게 바람직한지, 바람직하다면 그 이유도 느낄 수 있을 것 같다.

- 무엇을 전역 상태로 둘 것인지에 대한 근본적인 물음이 중요함. 생각 보다 전역 상태가 많이 안필요할 수도 있음. 써야 하니까 쓰지는 말자. 전역 상태에 들어갈게 애초에 뭔지 확실하게 잣대 잡기. /로그인 정보는 전역 상태로 두는게 대체로 맞음.
- 컴포넌트인지 페이지인지 레이어를 구분해서 하는 것도 좋음. 지금 나는 컴포넌트=페이지 개념으로도 많이 하는 듯… 아니면 페이지 개념으로 도큐먼트를 쓰던가.
- 정보의 원천을 하나로 해줘야 함. //

- useEffet 안에서 함수를 선언해줬을 때, 함수 호출 까지 해줘야 동작한다는 점 잊지 말기...
- 객체도 값만 배열로 추출 가능하구나... `console.log(Object.values(obj)); `

## 참고

- 구글 소셜 로그인 각각 코드 한줄한줄 의미 [링크](https://velog.io/@49crehbgr/Firebase-Google-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84)
- prop validation [블로그](https://haerim95.tistory.com/41)
- Firebase 리스너 연동 시 참고했던 공식 영상 [링크](https://www.youtube.com/watch?v=dBscwaqNPuk)

이전 커밋으로 돌아가기
하고 싶은 것:

- URL(userId, DocId) 물고 들어왔을 때
  - 로그인 했으면 바로 에디터로 진입 (text 불러오기)
  - 로그인 안했으면 (로그인 시키고)

키보드 커서 위치
키보드 이벤트 활용 > 키 놓으면, 혹은 키 누르면 나오는 속성 확인 > 그곳의 위치 좌표 체크 > 로직: 이 문서에서 키보드 이벤트 발생하면 해당 유저의 이름리 화면에 보인다

간단한 구조에서 실험해보기.. 바닐라로 한다면 어떻게 할 생각을 할까?
컴포넌트 렌더링
프롭으로 주고 테일윈드로 위치 조정

z-index는 태그들이 겹칠 때 누가 더 위로 올라가는지를 결정하는 속성입니다. 기본값은 0이고요. #top에 1을 주었기 때문에 다른 태그들보다 높게 위치합니다. 조금 뒤에 z-index 강좌가 나옵니다.

App: 로그인 된 상태면, Document 라우팅

- DocList, Editor 라우팅
- 이어서 라우팅으로 모두 연결해주기

문서 편집 (데이터는 거의 됐는데 라우팅, ui가 문제. 오늘 다 하기)

- Url은 /list/:userId인 상태: 특정 문서 클릭 > 해당 문서id를 파라미터로 보내주기(navigate) >
- 기존꺼 불러오기
-
- 자동 20초 저장 기능:

공동 편집 flow

- (다른 브라우저로 유저가 edit url 진입) 로그인 상태 체크
  - True:
    - edit url의 userId를 useParams로 가져오기 > 로그인 유저 id랑 비교 > (본인 or 다른 사람?)
      - 본인: 기존 수정 로직 타면 됨.
      - 다른사람:
  - False:
    - 로그인해라 > 처음 들어오려던 url로 보내줘서 위 로직(본인 or 다른 사람) 탈 수 있게 해주기.
